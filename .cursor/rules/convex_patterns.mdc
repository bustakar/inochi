---
description: Extended Convex best practices for function organization, auth patterns, and code reuse
globs: **/convex/**/*.ts
---

# Convex Patterns

This extends the base `convex_rules.mdc` with project-specific patterns.

## Function Organization

### Keep Handlers Small

Handler functions should be under 50 lines. Extract complex logic into helper functions.

```typescript
// GOOD: Small handler with helper functions
export const getPrivateExercises = query({
  args: { searchQuery: v.optional(v.string()) },
  returns: v.array(exerciseWithDetailsValidator),
  handler: async (ctx, args) => {
    const userId = await getUserId(ctx);
    if (!userId) throw new Error("Unauthorized");
    
    const exercises = await fetchUserExercises(ctx, userId, args.searchQuery);
    return enrichExercisesWithDetails(ctx, exercises);
  },
});

// Helper function - reusable across multiple queries
async function fetchUserExercises(
  ctx: QueryCtx,
  userId: string,
  searchQuery?: string,
): Promise<Array<Doc<"private_exercises">>> {
  if (searchQuery) {
    return ctx.db
      .query("private_exercises")
      .withSearchIndex("search_title", (q) => q.search("title", searchQuery))
      .filter((q) => q.eq(q.field("createdBy"), userId))
      .collect();
  }
  return ctx.db
    .query("private_exercises")
    .withIndex("by_user", (q) => q.eq("createdBy", userId))
    .collect();
}
```

### Helper Function Patterns

- Define helpers as regular `async function` (not exported)
- Type the context parameter: `ctx: QueryCtx` or `ctx: MutationCtx`
- Place helpers near the functions that use them
- Reuse helpers across multiple queries/mutations in the same file

## Authentication Pattern

### Always Use getUserId Helper

```typescript
import { getUserId } from "./auth";

export const updateExercise = mutation({
  args: { id: v.id("private_exercises"), title: v.string() },
  returns: v.null(),
  handler: async (ctx, args) => {
    // ALWAYS check auth first
    const userId = await getUserId(ctx);
    if (!userId) {
      throw new Error("Unauthorized");
    }
    
    // Verify ownership
    const exercise = await ctx.db.get(args.id);
    if (!exercise || exercise.createdBy !== userId) {
      throw new Error("Not found");
    }
    
    await ctx.db.patch(args.id, { title: args.title });
    return null;
  },
});
```

### Auth Check Checklist

Every mutation/query that accesses user data must:
1. Call `getUserId(ctx)` 
2. Check `if (!userId)` and throw "Unauthorized"
3. For owned resources, verify `resource.createdBy === userId` or `resource.userId === userId`

## Reusable Validators

### Define in validators/validators.ts

```typescript
// validators/validators.ts
import { Infer, v } from "convex/values";

export const exerciseLevelValidator = v.union(
  v.literal("beginner"),
  v.literal("intermediate"),
  v.literal("advanced"),
  v.literal("expert"),
  v.literal("elite"),
);

// Export type alongside validator
export type ExerciseLevel = Infer<typeof exerciseLevelValidator>;

// Complex object validators
export const exerciseValidator = v.object({
  title: v.string(),
  description: v.optional(v.string()),
  level: v.optional(exerciseLevelValidator),
  difficulty: v.optional(v.number()),
});
export type Exercise = Infer<typeof exerciseValidator>;
```

### Use Validators Consistently

```typescript
import { exerciseLevelValidator, exerciseValidator } from "../validators/validators";

export const createExercise = mutation({
  args: exerciseValidator,  // Reuse the validator
  returns: v.id("exercises"),
  handler: async (ctx, args) => {
    // args is typed as Exercise
    return ctx.db.insert("exercises", { ...args, createdAt: Date.now() });
  },
});
```

## Index Usage

### Always Use Indexes, Never Filter

```typescript
// GOOD: Using index
const exercises = await ctx.db
  .query("exercises")
  .withIndex("by_level", (q) => q.eq("level", "beginner"))
  .collect();

// BAD: Using filter (slow table scan)
const exercises = await ctx.db
  .query("exercises")
  .filter((q) => q.eq(q.field("level"), "beginner"))
  .collect();
```

### Index Naming Convention

Index name should include all fields: `by_field1_and_field2`

```typescript
// In schema.ts
exercises: defineTable({...})
  .index("by_level", ["level"])
  .index("by_category", ["category"])
  .index("by_level_and_category", ["level", "category"])
```

## Internal vs Public Functions

### Use Internal for Backend-Only Logic

```typescript
// Public: Called from React components
export const getExercise = query({...});

// Internal: Called only by other Convex functions
export const enrichWithMuscles = internalQuery({
  args: { exerciseId: v.id("exercises") },
  returns: v.array(muscleValidator),
  handler: async (ctx, args) => {
    // This is called by other functions, not directly from frontend
  },
});
```

### When to Use Internal Functions

- Helper logic called by multiple public functions
- Scheduled/cron job handlers
- Functions called from actions
- Any function that shouldn't be exposed to the client

## Business Logic Belongs Here

All business logic should live in Convex, not in React:

```typescript
// GOOD: Computation in Convex
export const getExerciseStats = query({
  args: { userId: v.string() },
  returns: statsValidator,
  handler: async (ctx, args) => {
    const exercises = await fetchUserExercises(ctx, args.userId);
    return {
      total: exercises.length,
      byLevel: groupByLevel(exercises),
      averageDifficulty: calculateAverageDifficulty(exercises),
      // All calculations done server-side
    };
  },
});
```

This ensures the same logic works for both web and native apps.
